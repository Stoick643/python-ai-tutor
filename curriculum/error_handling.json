{
  "topic_id": "error_handling",
  "title": "Error Handling and Debugging", 
  "description": "Learn to handle errors gracefully with try/except blocks and debug your Python programs",
  "difficulty": 4,
  "estimated_time": 30,
  "prerequisites": ["functions"],
  "levels": {
    "0": {
      "type": "concept",
      "content": "Error handling is the process of anticipating and managing errors that might occur during program execution. Instead of letting your program crash, you can catch errors and handle them gracefully. Python uses try/except blocks to catch exceptions. Good error handling makes your programs robust and user-friendly by providing meaningful error messages and alternative actions.",
      "explanation": "Exceptions are Python objects that represent errors. Common types include ValueError (invalid value), TypeError (wrong type), KeyError (missing dictionary key), and IndexError (list index out of range). The try block contains code that might fail, except blocks handle specific errors, else runs if no errors occur, and finally always runs regardless.",
      "key_concepts": ["try/except blocks", "Exception types", "Error handling vs debugging", "Graceful failure", "finally clause", "else clause"]
    },
    "1": {
      "type": "simple_example",
      "content": "Let's start with basic error handling using try/except blocks:",
      "code": "# Basic error handling\nprint(\"🔢 Safe Division Calculator\")\n\ndef safe_divide(a, b):\n    \"\"\"Safely divide two numbers with error handling.\"\"\"\n    try:\n        result = a / b\n        return f\"{a} ÷ {b} = {result}\"\n    except ZeroDivisionError:\n        return \"❌ Error: Cannot divide by zero!\"\n    except TypeError:\n        return \"❌ Error: Please use numbers only!\"\n\n# Test different scenarios\ntest_cases = [\n    (10, 2),      # Normal case\n    (15, 0),      # Division by zero\n    (\"8\", 4),     # String input (TypeError)\n    (20, 4)       # Another normal case\n]\n\nfor a, b in test_cases:\n    print(f\"\\nTesting: {a} ÷ {b}\")\n    print(safe_divide(a, b))\n\n# Handling user input errors\nprint(\"\\n🎯 Safe Number Input:\")\n\ndef get_safe_number(prompt):\n    \"\"\"Get a number from user with error handling.\"\"\"\n    try:\n        # Simulating user input\n        user_input = \"25\"  # This would be input(prompt) in real scenario\n        number = int(user_input)\n        return number\n    except ValueError:\n        print(\"❌ That's not a valid number!\")\n        return None\n\nnumber = get_safe_number(\"Enter a number: \")\nif number is not None:\n    print(f\"✅ You entered: {number}\")\n    print(f\"Double that number: {number * 2}\")",
      "output": "🔢 Safe Division Calculator\n\nTesting: 10 ÷ 2\n10 ÷ 2 = 5.0\n\nTesting: 15 ÷ 0\n❌ Error: Cannot divide by zero!\n\nTesting: 8 ÷ 4\n❌ Error: Please use numbers only!\n\nTesting: 20 ÷ 4\n20 ÷ 4 = 5.0\n\n🎯 Safe Number Input:\n✅ You entered: 25\nDouble that number: 50",
      "explanation": "The try block contains code that might raise an exception. Each except block handles a specific type of error. ZeroDivisionError occurs when dividing by zero, TypeError when using wrong data types. We return meaningful error messages instead of letting the program crash. This makes our functions more reliable and user-friendly.",
      "key_concepts": ["try/except syntax", "Specific exception handling", "ZeroDivisionError", "TypeError", "Graceful error messages"]
    },
    "2": {
      "type": "medium_example",
      "content": "Now let's explore multiple exception handling, else/finally clauses, and file operations:",
      "code": "# Advanced error handling with file operations\nimport json\n\ndef load_user_data(filename):\n    \"\"\"Load user data from JSON file with comprehensive error handling.\"\"\"\n    print(f\"🔍 Attempting to load: {filename}\")\n    \n    try:\n        # Simulate file content for demo\n        if filename == \"users.json\":\n            file_content = '{\"users\": [{\"name\": \"Alice\", \"age\": 25}, {\"name\": \"Bob\", \"age\": 30}]}'\n        elif filename == \"invalid.json\":\n            file_content = '{\"users\": [invalid json}'\n        else:\n            raise FileNotFoundError(\"File not found\")\n            \n        # Parse JSON data\n        data = json.loads(file_content)\n        user_count = len(data.get(\"users\", []))\n        \n    except FileNotFoundError:\n        print(\"❌ Error: File not found!\")\n        return None\n    except json.JSONDecodeError as e:\n        print(f\"❌ Error: Invalid JSON format - {e}\")\n        return None\n    except KeyError as e:\n        print(f\"❌ Error: Missing required key - {e}\")\n        return None\n    except Exception as e:\n        print(f\"❌ Unexpected error occurred: {e}\")\n        return None\n    else:\n        print(f\"✅ Successfully loaded {user_count} users\")\n        return data\n    finally:\n        print(f\"🔧 Cleanup: Finished processing {filename}\")\n\n# Dictionary access with error handling\ndef get_user_info(users_data, user_index):\n    \"\"\"Get user information with safe dictionary/list access.\"\"\"\n    try:\n        users = users_data[\"users\"]\n        user = users[user_index]\n        name = user[\"name\"]\n        age = user[\"age\"]\n        return f\"User: {name} (age {age})\"\n    except (KeyError, IndexError, TypeError) as e:\n        return f\"❌ Error accessing user data: {type(e).__name__}\"\n\n# Mathematical operations with validation\ndef calculate_average_age(users_data):\n    \"\"\"Calculate average age with error handling.\"\"\"\n    try:\n        users = users_data[\"users\"]\n        if not users:\n            raise ValueError(\"No users found\")\n        \n        ages = [user[\"age\"] for user in users]\n        average = sum(ages) / len(ages)\n        return round(average, 1)\n    except (KeyError, TypeError, ZeroDivisionError, ValueError) as e:\n        print(f\"❌ Cannot calculate average: {type(e).__name__}\")\n        return None\n\n# Test the error handling system\nprint(\"📁 File Loading Tests:\")\n\n# Test successful file loading\ndata = load_user_data(\"users.json\")\nif data:\n    print(\"\\n👤 User Information:\")\n    print(get_user_info(data, 0))  # First user\n    print(get_user_info(data, 1))  # Second user\n    print(get_user_info(data, 5))  # Index error\n    \n    avg_age = calculate_average_age(data)\n    if avg_age:\n        print(f\"\\n📊 Average age: {avg_age} years\")\n\nprint(\"\\n\" + \"=\"*50)\n\n# Test file with invalid JSON\nprint(\"\\n📁 Testing invalid JSON:\")\ninvalid_data = load_user_data(\"invalid.json\")\n\nprint(\"\\n📁 Testing missing file:\")\nmissing_data = load_user_data(\"missing.json\")",
      "output": "📁 File Loading Tests:\n🔍 Attempting to load: users.json\n✅ Successfully loaded 2 users\n🔧 Cleanup: Finished processing users.json\n\n👤 User Information:\nUser: Alice (age 25)\nUser: Bob (age 30)\n❌ Error accessing user data: IndexError\n\n📊 Average age: 27.5 years\n\n==================================================\n\n📁 Testing invalid JSON:\n🔍 Attempting to load: invalid.json\n❌ Error: Invalid JSON format - Expecting property name enclosed in double quotes: line 1 column 13 (char 12)\n🔧 Cleanup: Finished processing invalid.json\n\n📁 Testing missing file:\n🔍 Attempting to load: missing.json\n❌ Error: File not found!\n🔧 Cleanup: Finished processing missing.json",
      "explanation": "This example demonstrates comprehensive error handling patterns. We handle multiple exception types in one except clause using parentheses. The 'as e' syntax captures the exception object for detailed error messages. The 'else' clause runs only if no exceptions occur, while 'finally' always executes for cleanup. We also show how to handle nested data access safely.",
      "key_concepts": ["Multiple exception handling", "Exception objects with 'as'", "else and finally clauses", "json.JSONDecodeError", "Nested exception handling", "Safe data access patterns"]
    },
    "3": {
      "type": "complex_example",
      "content": "Here's a sophisticated banking system with comprehensive error handling and custom exceptions:",
      "code": "# Advanced Banking System with Custom Exceptions\n\nclass InsufficientFundsError(Exception):\n    \"\"\"Custom exception for insufficient funds.\"\"\"\n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n        super().__init__(f\"Insufficient funds: ${balance:.2f} available, ${amount:.2f} requested\")\n\nclass InvalidAccountError(Exception):\n    \"\"\"Custom exception for invalid account operations.\"\"\"\n    pass\n\nclass BankAccount:\n    \"\"\"A bank account with comprehensive error handling.\"\"\"\n    \n    def __init__(self, account_number, initial_balance=0):\n        if not isinstance(account_number, str) or len(account_number) != 10:\n            raise ValueError(\"Account number must be a 10-character string\")\n        if initial_balance < 0:\n            raise ValueError(\"Initial balance cannot be negative\")\n            \n        self.account_number = account_number\n        self.balance = float(initial_balance)\n        self.transaction_history = []\n        self.is_active = True\n    \n    def deposit(self, amount):\n        \"\"\"Deposit money with validation.\"\"\"\n        try:\n            if not self.is_active:\n                raise InvalidAccountError(\"Account is closed\")\n            \n            amount = float(amount)\n            if amount <= 0:\n                raise ValueError(\"Deposit amount must be positive\")\n            if amount > 10000:\n                raise ValueError(\"Single deposit cannot exceed $10,000\")\n                \n            self.balance += amount\n            self.transaction_history.append((\"DEPOSIT\", amount, self.balance))\n            return f\"✅ Deposited ${amount:.2f}. New balance: ${self.balance:.2f}\"\n            \n        except ValueError as e:\n            return f\"❌ Deposit failed: {e}\"\n        except InvalidAccountError as e:\n            return f\"❌ Account error: {e}\"\n        except Exception as e:\n            return f\"❌ Unexpected error during deposit: {e}\"\n    \n    def withdraw(self, amount):\n        \"\"\"Withdraw money with comprehensive validation.\"\"\"\n        try:\n            if not self.is_active:\n                raise InvalidAccountError(\"Account is closed\")\n                \n            amount = float(amount)\n            if amount <= 0:\n                raise ValueError(\"Withdrawal amount must be positive\")\n            if amount > self.balance:\n                raise InsufficientFundsError(self.balance, amount)\n            if amount > 5000:\n                raise ValueError(\"Single withdrawal cannot exceed $5,000\")\n                \n            self.balance -= amount\n            self.transaction_history.append((\"WITHDRAWAL\", amount, self.balance))\n            return f\"✅ Withdrew ${amount:.2f}. New balance: ${self.balance:.2f}\"\n            \n        except InsufficientFundsError as e:\n            return f\"❌ {e}\"\n        except ValueError as e:\n            return f\"❌ Withdrawal failed: {e}\"\n        except InvalidAccountError as e:\n            return f\"❌ Account error: {e}\"\n        except Exception as e:\n            return f\"❌ Unexpected error during withdrawal: {e}\"\n    \n    def transfer(self, target_account, amount):\n        \"\"\"Transfer money between accounts.\"\"\"\n        try:\n            if not isinstance(target_account, BankAccount):\n                raise TypeError(\"Target must be a BankAccount object\")\n            if target_account.account_number == self.account_number:\n                raise ValueError(\"Cannot transfer to the same account\")\n                \n            # Attempt withdrawal first\n            withdrawal_result = self.withdraw(amount)\n            if \"❌\" in withdrawal_result:\n                return f\"Transfer failed: {withdrawal_result}\"\n                \n            # Attempt deposit to target\n            deposit_result = target_account.deposit(amount)\n            if \"❌\" in deposit_result:\n                # Rollback withdrawal\n                self.balance += float(amount)\n                self.transaction_history.append((\"ROLLBACK\", amount, self.balance))\n                return f\"Transfer failed during deposit: {deposit_result}\"\n                \n            self.transaction_history.append((\"TRANSFER_OUT\", amount, self.balance))\n            target_account.transaction_history.append((\"TRANSFER_IN\", amount, target_account.balance))\n            \n            return f\"✅ Transferred ${amount:.2f} to account {target_account.account_number}\"\n            \n        except (TypeError, ValueError) as e:\n            return f\"❌ Transfer failed: {e}\"\n        except Exception as e:\n            return f\"❌ Unexpected error during transfer: {e}\"\n    \n    def get_statement(self):\n        \"\"\"Generate account statement with error handling.\"\"\"\n        try:\n            if not self.transaction_history:\n                return \"No transactions found.\"\n                \n            statement = f\"\\n💳 Account Statement - {self.account_number}\\n\"\n            statement += \"=\" * 50 + \"\\n\"\n            statement += f\"Current Balance: ${self.balance:.2f}\\n\"\n            statement += f\"Account Status: {'Active' if self.is_active else 'Closed'}\\n\\n\"\n            \n            statement += \"Recent Transactions:\\n\"\n            for i, (trans_type, amount, balance) in enumerate(self.transaction_history[-5:], 1):\n                statement += f\"{i}. {trans_type}: ${amount:.2f} (Balance: ${balance:.2f})\\n\"\n                \n            return statement\n            \n        except Exception as e:\n            return f\"❌ Error generating statement: {e}\"\n\n# Banking System Demo\nprint(\"🏦 ADVANCED BANKING SYSTEM DEMO\")\nprint(\"=\" * 60)\n\ntry:\n    # Create accounts\n    print(\"\\n📝 Creating accounts...\")\n    alice_account = BankAccount(\"1234567890\", 1000)\n    bob_account = BankAccount(\"0987654321\", 500)\n    print(\"✅ Accounts created successfully\")\n    \n    # Test various operations\n    print(\"\\n💰 Testing deposits:\")\n    print(alice_account.deposit(500))    # Valid deposit\n    print(alice_account.deposit(-100))   # Invalid amount\n    print(alice_account.deposit(15000))  # Exceeds limit\n    \n    print(\"\\n💸 Testing withdrawals:\")\n    print(bob_account.withdraw(200))     # Valid withdrawal\n    print(bob_account.withdraw(1000))    # Insufficient funds\n    print(bob_account.withdraw(6000))    # Exceeds limit\n    \n    print(\"\\n🔄 Testing transfers:\")\n    print(alice_account.transfer(bob_account, 300))  # Valid transfer\n    print(bob_account.transfer(alice_account, 1000)) # Insufficient funds\n    \n    # Generate statements\n    print(alice_account.get_statement())\n    print(bob_account.get_statement())\n    \nexcept ValueError as e:\n    print(f\"❌ Account creation failed: {e}\")\nexcept Exception as e:\n    print(f\"❌ System error: {e}\")\n\nprint(\"\\n🔍 Testing invalid account creation:\")\ntry:\n    invalid_account = BankAccount(\"123\", -100)  # Short number and negative balance\nexcept ValueError as e:\n    print(f\"❌ Expected error: {e}\")",
      "output": "🏦 ADVANCED BANKING SYSTEM DEMO\n============================================================\n\n📝 Creating accounts...\n✅ Accounts created successfully\n\n💰 Testing deposits:\n✅ Deposited $500.00. New balance: $1500.00\n❌ Deposit failed: Deposit amount must be positive\n❌ Deposit failed: Single deposit cannot exceed $10,000\n\n💸 Testing withdrawals:\n✅ Withdrew $200.00. New balance: $300.00\n❌ Insufficient funds: $300.00 available, $1000.00 requested\n❌ Withdrawal failed: Single withdrawal cannot exceed $5,000\n\n🔄 Testing transfers:\n✅ Transferred $300.00 to account 0987654321\n❌ Transfer failed: ❌ Insufficient funds: $600.00 available, $1000.00 requested\n\n💳 Account Statement - 1234567890\n==================================================\nCurrent Balance: $1200.00\nAccount Status: Active\n\nRecent Transactions:\n1. DEPOSIT: $500.00 (Balance: $1500.00)\n2. TRANSFER_OUT: $300.00 (Balance: $1200.00)\n\n💳 Account Statement - 0987654321\n==================================================\nCurrent Balance: $600.00\nAccount Status: Active\n\nRecent Transactions:\n1. WITHDRAWAL: $200.00 (Balance: $300.00)\n2. TRANSFER_IN: $300.00 (Balance: $600.00)\n\n🔍 Testing invalid account creation:\n❌ Expected error: Account number must be a 10-character string",
      "explanation": "This comprehensive example demonstrates advanced error handling concepts including custom exceptions, exception inheritance, rollback mechanisms, and defensive programming. We create custom exception classes that inherit from Exception, use comprehensive validation, implement rollback logic for failed operations, and demonstrate how proper error handling makes complex systems robust and reliable.",
      "key_concepts": ["Custom exceptions", "Exception inheritance", "Defensive programming", "Rollback mechanisms", "Complex validation", "System-level error handling"]
    }
  },
  "challenges": [
    {
      "prompt": "Create a safe calculator that handles division and square root operations:\n- Write a function calculate(operation, a, b=None) that supports \"divide\", \"sqrt\"\n- Handle ZeroDivisionError, ValueError, and TypeError appropriately\n- For division: handle division by zero\n- For square root: handle negative numbers (you can simulate math.sqrt with x**0.5)\n- Return meaningful error messages or the result\n\nTest with: divide(10, 2), divide(10, 0), sqrt(16), sqrt(-4), sqrt(\"invalid\")",
      "solution": "def calculate(operation, a, b=None):\n    \"\"\"Safe calculator with comprehensive error handling.\"\"\"\n    try:\n        if operation == \"divide\":\n            if b is None:\n                return \"❌ Error: Division requires two numbers\"\n            if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n                raise TypeError(\"Both operands must be numbers\")\n            if b == 0:\n                raise ZeroDivisionError(\"Cannot divide by zero\")\n            return f\"{a} ÷ {b} = {a / b}\"\n            \n        elif operation == \"sqrt\":\n            if not isinstance(a, (int, float)):\n                raise TypeError(\"Square root requires a number\")\n            if a < 0:\n                raise ValueError(\"Cannot calculate square root of negative number\")\n            result = a ** 0.5\n            return f\"√{a} = {result}\"\n            \n        else:\n            return f\"❌ Error: Unknown operation '{operation}'\"\n            \n    except ZeroDivisionError as e:\n        return f\"❌ Division Error: {e}\"\n    except ValueError as e:\n        return f\"❌ Value Error: {e}\"\n    except TypeError as e:\n        return f\"❌ Type Error: {e}\"\n    except Exception as e:\n        return f\"❌ Unexpected Error: {e}\"\n\n# Test the calculator\nprint(\"🧮 Safe Calculator Demo\")\nprint(\"=\" * 30)\n\ntest_cases = [\n    (\"divide\", 10, 2),      # Valid division\n    (\"divide\", 10, 0),      # Division by zero\n    (\"sqrt\", 16),           # Valid square root\n    (\"sqrt\", -4),           # Negative square root\n    (\"sqrt\", \"invalid\"),    # Invalid type\n    (\"power\", 2, 3),        # Unknown operation\n]\n\nfor case in test_cases:\n    if len(case) == 3:\n        op, x, y = case\n        result = calculate(op, x, y)\n    else:\n        op, x = case\n        result = calculate(op, x)\n    \n    print(f\"\\nOperation: {case}\")\n    print(f\"Result: {result}\")",
      "hints": ["Use isinstance() to check data types", "Handle each exception type specifically", "Check for None values in optional parameters", "Use ** operator for exponentiation (square root is x**0.5)"],
      "difficulty": 2
    },
    {
      "prompt": "Build a robust data processor for a list of dictionaries:\n- Write process_users(users_list) that processes user data safely\n- Each user dict should have: name, age, email\n- Calculate average age, count valid emails (contain @), find oldest user\n- Handle missing keys, wrong data types, empty lists\n- Return a summary dict with results or error message\n\nTest with: [{\"name\": \"Alice\", \"age\": 25, \"email\": \"alice@test.com\"}, {\"name\": \"Bob\", \"age\": \"thirty\"}, {\"email\": \"charlie@test.com\"}]",
      "solution": "def process_users(users_list):\n    \"\"\"Process user data with comprehensive error handling.\"\"\"\n    try:\n        # Validate input\n        if not isinstance(users_list, list):\n            raise TypeError(\"Input must be a list\")\n        \n        if not users_list:\n            return {\"error\": \"Empty user list provided\"}\n        \n        valid_users = []\n        valid_ages = []\n        valid_emails = 0\n        processing_errors = []\n        \n        # Process each user\n        for i, user in enumerate(users_list):\n            try:\n                if not isinstance(user, dict):\n                    raise TypeError(f\"User {i} is not a dictionary\")\n                \n                # Process name\n                name = user.get(\"name\", f\"Unknown_{i}\")\n                if not isinstance(name, str):\n                    name = f\"User_{i}\"\n                \n                # Process age\n                age = None\n                if \"age\" in user:\n                    try:\n                        age = int(user[\"age\"])\n                        if age < 0 or age > 150:\n                            raise ValueError(f\"Invalid age: {age}\")\n                        valid_ages.append(age)\n                    except (ValueError, TypeError):\n                        processing_errors.append(f\"User {i} ({name}): Invalid age '{user['age']}'\")\n                \n                # Process email\n                email = user.get(\"email\", \"\")\n                if isinstance(email, str) and \"@\" in email and \".\" in email:\n                    valid_emails += 1\n                elif email:  # Non-empty but invalid\n                    processing_errors.append(f\"User {i} ({name}): Invalid email '{email}'\")\n                \n                # Store valid user info\n                valid_users.append({\n                    \"name\": name,\n                    \"age\": age,\n                    \"email\": email,\n                    \"index\": i\n                })\n                \n            except Exception as e:\n                processing_errors.append(f\"Error processing user {i}: {e}\")\n                continue\n        \n        # Calculate statistics\n        summary = {\n            \"total_users\": len(users_list),\n            \"processed_users\": len(valid_users),\n            \"valid_emails\": valid_emails,\n            \"processing_errors\": processing_errors\n        }\n        \n        # Average age\n        if valid_ages:\n            summary[\"average_age\"] = round(sum(valid_ages) / len(valid_ages), 1)\n            summary[\"users_with_age\"] = len(valid_ages)\n        else:\n            summary[\"average_age\"] = None\n            summary[\"users_with_age\"] = 0\n        \n        # Oldest user\n        if valid_ages:\n            oldest_age = max(valid_ages)\n            oldest_users = [u for u in valid_users if u[\"age\"] == oldest_age]\n            summary[\"oldest_user\"] = {\n                \"name\": oldest_users[0][\"name\"],\n                \"age\": oldest_age\n            }\n        else:\n            summary[\"oldest_user\"] = None\n        \n        return summary\n        \n    except TypeError as e:\n        return {\"error\": f\"Type Error: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"Unexpected error: {e}\"}\n\n# Test the data processor\nprint(\"📊 User Data Processor Demo\")\nprint(\"=\" * 40)\n\n# Test data with various issues\ntest_users = [\n    {\"name\": \"Alice\", \"age\": 25, \"email\": \"alice@test.com\"},\n    {\"name\": \"Bob\", \"age\": \"thirty\"},  # Invalid age\n    {\"email\": \"charlie@test.com\"},      # Missing name and age\n    {\"name\": \"Diana\", \"age\": 35, \"email\": \"invalid-email\"},  # Invalid email\n    {\"name\": \"Eve\", \"age\": 28, \"email\": \"eve@example.com\"},\n    \"not_a_dict\"  # Invalid user format\n]\n\nresult = process_users(test_users)\n\nprint(\"\\n📋 Processing Results:\")\nprint(f\"Total users: {result.get('total_users', 'N/A')}\")\nprint(f\"Successfully processed: {result.get('processed_users', 'N/A')}\")\nprint(f\"Valid emails: {result.get('valid_emails', 'N/A')}\")\nprint(f\"Users with valid age: {result.get('users_with_age', 'N/A')}\")\nprint(f\"Average age: {result.get('average_age', 'N/A')}\")\n\nif result.get('oldest_user'):\n    oldest = result['oldest_user']\n    print(f\"Oldest user: {oldest['name']} (age {oldest['age']})\")\n\nif result.get('processing_errors'):\n    print(\"\\n⚠️ Processing Errors:\")\n    for error in result['processing_errors']:\n        print(f\"  • {error}\")\n\nif result.get('error'):\n    print(f\"\\n❌ Fatal Error: {result['error']}\")\n\n# Test with empty list\nprint(\"\\n🔍 Testing edge cases:\")\nempty_result = process_users([])\nprint(f\"Empty list result: {empty_result}\")\n\ninvalid_result = process_users(\"not a list\")\nprint(f\"Invalid input result: {invalid_result}\")",
      "hints": ["Use .get() method for safe dictionary access", "Validate each piece of data individually", "Collect errors instead of stopping on first error", "Use isinstance() to check data types", "Handle each user independently in a loop"],
      "difficulty": 3
    }
  ]
}
